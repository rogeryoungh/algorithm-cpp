<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法库 on Roger Young</title>
    <link>https://algo-cpp.rogery.dev/</link>
    <description>Recent content in 算法库 on Roger Young</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>© 2023 [Roger Young](https://rogery.dev)</copyright>
    <lastBuildDate>Fri, 20 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://algo-cpp.rogery.dev/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>多项式 EXP 14E 分块</title>
      <link>https://algo-cpp.rogery.dev/post/math/poly/exp-14e-nt-block/</link>
      <pubDate>Sat, 28 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/poly/exp-14e-nt-block/</guid>
      <description>多项式 EXP 14E #ifndef ALGO_MATH_POLY_EXP14E_NTBLOCK #define ALGO_MATH_POLY_EXP14E_NTBLOCK #include &amp;quot;../../base.hpp&amp;quot; #include &amp;quot;ntt.hpp&amp;quot; #include &amp;quot;vec-dots.hpp&amp;quot; #include &amp;quot;nt-block-helper.hpp&amp;quot; #include &amp;quot;inv-10E-nt-block.hpp&amp;quot; #include &amp;quot;../constant/prepare-inv.hpp&amp;quot; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;iostream&amp;gt; template &amp;lt;static_modint_concept ModT&amp;gt; std::vector&amp;lt;ModT&amp;gt; poly_exp_14E_block(std::span&amp;lt;const ModT&amp;gt; self, u32 m) { if (m == 1) return {1}; auto [n, u] = detail::nt_block_len(m); std::vector&amp;lt;ModT&amp;gt; x = poly_exp_14E_block(self, n), h = poly_inv_10E_block&amp;lt;ModT&amp;gt;(x, n); x.resize(n * u), h.resize(n * 2); std::vector&amp;lt;ModT&amp;gt; nf0(n * u * 2), ng0(n * u * 2); auto &amp;amp;iv = prepare_inv&amp;lt;ModT&amp;gt;(n * u); auto nf = detail::nt_block_split(nf0, n * 2); auto ng = detail::nt_block_split(ng0, n * 2); auto xk = detail::nt_block_split(x, n); ntt&amp;lt;ModT&amp;gt;(h); for (u32 k = 0; k &amp;lt; u; ++k) { std::copy(self.</description>
    </item>
    
    <item>
      <title>多项式开根 8E</title>
      <link>https://algo-cpp.rogery.dev/post/math/poly/sqrt-8e-nt-block/</link>
      <pubDate>Fri, 27 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/poly/sqrt-8e-nt-block/</guid>
      <description>多项式开根 8E #ifndef ALGO_MATH_POLY_SQRT8E_NTBLOCK #define ALGO_MATH_POLY_SQRT8E_NTBLOCK #include &amp;quot;../../base.hpp&amp;quot; #include &amp;quot;ntt.hpp&amp;quot; #include &amp;quot;inv-10E-nt.hpp&amp;quot; #include &amp;quot;nt-block-helper.hpp&amp;quot; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;iostream&amp;gt; template &amp;lt;static_modint_concept ModT&amp;gt; std::vector&amp;lt;ModT&amp;gt; poly_sqrt_8E_block(std::span&amp;lt;const ModT&amp;gt; self, u32 m, const ModT &amp;amp;x0) { if (m == 1) return {x0}; auto [n, u] = detail::nt_block_len(m); std::vector&amp;lt;ModT&amp;gt; x = poly_sqrt_8E_block(self, n, x0), h = poly_inv_10E&amp;lt;ModT&amp;gt;(x, n); x.resize(n * u), h.resize(n * 2); std::vector&amp;lt;ModT&amp;gt; ng0(n * u * 2); auto ng = detail::nt_block_split(ng0, n * 2); auto xk = detail::nt_block_split(x, n); ntt&amp;lt;ModT&amp;gt;(h); for (u32 k = 1; k &amp;lt; u; ++k) { std::copy(xk[k - 1].</description>
    </item>
    
    <item>
      <title>多项式 EXP 17E</title>
      <link>https://algo-cpp.rogery.dev/post/math/poly/exp-17e-nt/</link>
      <pubDate>Wed, 25 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/poly/exp-17e-nt/</guid>
      <description>多项式除法 17E #ifndef ALGO_MATH_POLY_EXP17ENT #define ALGO_MATH_POLY_EXP17ENT #include &amp;quot;../../base.hpp&amp;quot; #include &amp;quot;ntt.hpp&amp;quot; #include &amp;quot;../constant/prepare-inv.hpp&amp;quot; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;iostream&amp;gt; template &amp;lt;static_modint_concept ModT&amp;gt; std::vector&amp;lt;ModT&amp;gt; poly_exp_17E(std::span&amp;lt;const ModT&amp;gt; self, u32 m) { u32 n = std::bit_ceil(m); auto &amp;amp;iv = prepare_inv&amp;lt;ModT&amp;gt;(n); std::vector&amp;lt;ModT&amp;gt; f(n), g(n); f[0] = g[0] = 1; if (m == 1) return f; f[1] = self[1]; auto nf = f, ng = g; ntt&amp;lt;ModT&amp;gt;({ng.begin(), 2}); for (u32 t = 2; t &amp;lt; n; t *= 2) { std::copy_n(f.</description>
    </item>
    
    <item>
      <title>多项式乘法逆 10E</title>
      <link>https://algo-cpp.rogery.dev/post/math/poly/inv-10e-nt/</link>
      <pubDate>Tue, 24 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/poly/inv-10e-nt/</guid>
      <description>多项式乘法逆 10E #ifndef ALGO_MATH_POLY_INV10ENT #define ALGO_MATH_POLY_INV10ENT #include &amp;quot;../../base.hpp&amp;quot; #include &amp;quot;ntt.hpp&amp;quot; #include &amp;quot;vec-dots.hpp&amp;quot; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; template &amp;lt;static_modint_concept ModT&amp;gt; auto poly_inv_10E(std::span&amp;lt;const ModT&amp;gt; f, u32 m) { u32 n = std::bit_ceil(m); std::vector&amp;lt;ModT&amp;gt; x(n); x[0] = f[0].inv(); for (u32 t = 1; t &amp;lt; n; t *= 2) { std::vector&amp;lt;ModT&amp;gt; f2(t * 2), nx(t * 2); std::copy(f.begin(), std::min(f.begin() + t * 2, f.end()), f2.begin()); std::copy_n(x.begin(), t * 2, nx.begin()); ntt&amp;lt;ModT&amp;gt;(f2); // 2E ntt&amp;lt;ModT&amp;gt;(nx); // 2E dot&amp;lt;ModT&amp;gt;(f2, nx); intt&amp;lt;ModT&amp;gt;(f2); // 2E std::fill_n(f2.</description>
    </item>
    
    <item>
      <title>多项式乘法逆 10E 分块</title>
      <link>https://algo-cpp.rogery.dev/post/math/poly/inv-10e-nt-block/</link>
      <pubDate>Tue, 24 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/poly/inv-10e-nt-block/</guid>
      <description>多项式乘法逆 10E #ifndef ALGO_MATH_POLY_INV10E_NTBLOCK #define ALGO_MATH_POLY_INV10E_NTBLOCK #include &amp;quot;../../base.hpp&amp;quot; #include &amp;quot;ntt.hpp&amp;quot; #include &amp;quot;vec-dots.hpp&amp;quot; #include &amp;quot;nt-block-helper.hpp&amp;quot; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;iostream&amp;gt; template &amp;lt;static_modint_concept ModT&amp;gt; std::vector&amp;lt;ModT&amp;gt; poly_inv_10E_block(std::span&amp;lt;const ModT&amp;gt; self, u32 m) { if (m == 1) return {self[0].inv()}; auto [n, u] = detail::nt_block_len(m); std::vector&amp;lt;ModT&amp;gt; x = poly_inv_10E_block(self, n); x.resize(n * u); std::vector&amp;lt;ModT&amp;gt; nf0(n * u * 2), ng0(n * u * 2); auto nf = detail::nt_block_split(nf0, n * 2); auto ng = detail::nt_block_split(ng0, n * 2); auto xk = detail::nt_block_split(x, n); for (u32 k = 0; k &amp;lt; u; ++k) { std::copy(self.</description>
    </item>
    
    <item>
      <title>多项式乘法逆 12E</title>
      <link>https://algo-cpp.rogery.dev/post/math/poly/inv-12e-nt/</link>
      <pubDate>Tue, 24 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/poly/inv-12e-nt/</guid>
      <description>多项式乘法逆 12E #ifndef ALGO_MATH_POLY_INV12ENT #define ALGO_MATH_POLY_INV12ENT #include &amp;quot;../../base.hpp&amp;quot; #include &amp;quot;../../other/modint/modint-concept.hpp&amp;quot; #include &amp;quot;ntt.hpp&amp;quot; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; template &amp;lt;static_modint_concept ModT&amp;gt; auto poly_inv_12E(std::span&amp;lt;const ModT&amp;gt; f, u32 m) { u32 n = std::bit_ceil(m); std::vector&amp;lt;ModT&amp;gt; x(n * 2); x[0] = f[0].inv(); for (u32 t = 1; t &amp;lt; n; t *= 2) { std::span xt{x.begin(), x.begin() + t * 4}; std::vector&amp;lt;ModT&amp;gt; u(t * 4); std::copy(f.begin(), std::min(f.begin() + t * 2, f.end()), u.begin()); ntt&amp;lt;ModT&amp;gt;(u); // 4E ntt&amp;lt;ModT&amp;gt;(xt); // 4E for (u32 i = 0; i &amp;lt; t * 4; ++i) { x[i] = (ModT(2) + -u[i] * x[i]) * x[i]; } intt&amp;lt;ModT&amp;gt;(xt); // 4E std::fill_n(x.</description>
    </item>
    
    <item>
      <title>多项式开根 11E</title>
      <link>https://algo-cpp.rogery.dev/post/math/poly/sqrt-11e-nt/</link>
      <pubDate>Tue, 24 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/poly/sqrt-11e-nt/</guid>
      <description>多项式开根 11E #ifndef ALGO_MATH_POLY_SQRT11ENT #define ALGO_MATH_POLY_SQRT11ENT #include &amp;quot;../../base.hpp&amp;quot; #include &amp;quot;ntt.hpp&amp;quot; #include &amp;quot;vec-dots.hpp&amp;quot; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;iostream&amp;gt; template &amp;lt;static_modint_concept ModT&amp;gt; std::vector&amp;lt;ModT&amp;gt; poly_sqrt_11E(std::span&amp;lt;const ModT&amp;gt; self, u32 m, const ModT &amp;amp;x0) { u32 n = std::bit_ceil(m); std::vector&amp;lt;ModT&amp;gt; x(n), g(n), ng(n); x[0] = x0; if (n == 1) return x; ng[0] = g[0] = x[0].inv(); x[1] = (self[1] * g[0]).shift2(); ntt&amp;lt;ModT&amp;gt;({ng.begin(), 2}); for (u32 t = 2; t &amp;lt; n; t *= 2) { std::vector&amp;lt;ModT&amp;gt; f(t * 2), nf(t); std::copy_n(x.</description>
    </item>
    
    <item>
      <title>多项式除法 10E 分块</title>
      <link>https://algo-cpp.rogery.dev/post/math/poly/div-10e-nt-block/</link>
      <pubDate>Tue, 24 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/poly/div-10e-nt-block/</guid>
      <description>多项式除法 10E #ifndef ALGO_MATH_POLY_DIV10E_NTBLOCK #define ALGO_MATH_POLY_DIV10E_NTBLOCK #include &amp;quot;../../base.hpp&amp;quot; #include &amp;quot;ntt.hpp&amp;quot; #include &amp;quot;inv-10E-nt-block.hpp&amp;quot; #include &amp;quot;nt-block-helper.hpp&amp;quot; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;iostream&amp;gt; template &amp;lt;static_modint_concept ModT&amp;gt; std::vector&amp;lt;ModT&amp;gt; poly_div_10E_block(std::span&amp;lt;const ModT&amp;gt; lhs, std::span&amp;lt;const ModT&amp;gt; rhs, u32 m) { if (lhs.empty() || rhs.empty()) return {}; if (m == 1) return {lhs[0] / rhs[0]}; auto [n, u] = detail::nt_block_len(m); std::vector&amp;lt;ModT&amp;gt; x = poly_div_10E_block(lhs, rhs, n), h = poly_inv_10E_block(rhs, n); x.resize(n * u), h.resize(n * 2); std::vector&amp;lt;ModT&amp;gt; nf0(n * u * 2), ng0(n * u * 2); auto nf = detail::nt_block_split(nf0, n * 2); auto ng = detail::nt_block_split(ng0, n * 2); auto xk = detail::nt_block_split(x, n); ntt&amp;lt;ModT&amp;gt;(h); for (u32 k = 0; k &amp;lt; u; ++k) { std::copy(rhs.</description>
    </item>
    
    <item>
      <title>多项式除法 13E</title>
      <link>https://algo-cpp.rogery.dev/post/math/poly/div-13e-nt/</link>
      <pubDate>Tue, 24 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/poly/div-13e-nt/</guid>
      <description>多项式除法 13E #ifndef ALGO_MATH_POLY_DIV13ENT #define ALGO_MATH_POLY_DIV13ENT #include &amp;quot;../../base.hpp&amp;quot; #include &amp;quot;ntt.hpp&amp;quot; #include &amp;quot;inv-10E-nt.hpp&amp;quot; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;iostream&amp;gt; template &amp;lt;static_modint_concept ModT&amp;gt; std::vector&amp;lt;ModT&amp;gt; poly_div_13E(std::span&amp;lt;const ModT&amp;gt; lhs, std::span&amp;lt;const ModT&amp;gt; rhs, u32 m) { if (lhs.empty() || rhs.empty()) return {}; if (m == 1) return {lhs[0] / rhs[0]}; u32 t = std::bit_ceil(m); std::vector&amp;lt;ModT&amp;gt; g(t), x(t), q(t); std::vector&amp;lt;ModT&amp;gt; u = poly_inv_10E&amp;lt;ModT&amp;gt;(rhs, t / 2); // 5E std::copy(rhs.begin(), std::min(rhs.begin() + t, rhs.end()), g.begin()); std::copy(lhs.begin(), std::min(lhs.begin() + t / 2, lhs.</description>
    </item>
    
    <item>
      <title>Baillie PSW 素性测试</title>
      <link>https://algo-cpp.rogery.dev/post/math/primality-test/baillie-psw/</link>
      <pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/primality-test/baillie-psw/</guid>
      <description>理论 理论我也讲不出啥。
一个显然的观察是，Fermat 反素数和 Lucas 反素数的从计算过程来看就很不一样，换基不如换算法。把两个算法糅到一块就行了。
算法描述 输入整数 $N$ 。
试除小素数，若能整除则输出 $N$ 为合数。 使用基为 $2$ 的 Miller Rabin 算法 进行一次 Lucas 素性测试判断。 $2^{64}$ 内无反例。
备注 在 LOJ143 上跑起来没 Miller Rabin 算法快，也可能是数据有所针对。
参考 素数判定 - mathmu Baillie–PSW primality test - Wikipedia 代码 #ifndef ALGO_MATH_BAILLIE_PSW #define ALGO_MATH_BAILLIE_PSW #include &amp;quot;../../base.hpp&amp;quot; #include &amp;quot;miller-rabin.hpp&amp;quot; #include &amp;quot;lucas.hpp&amp;quot; bool baillie_psw_test(u64 n) { if (n &amp;lt;= 6) return n == 2 || n == 3 || n == 5; if (n % 6 !</description>
    </item>
    
    <item>
      <title>Miller Rabin 素性测试</title>
      <link>https://algo-cpp.rogery.dev/post/math/primality-test/miller-rabin/</link>
      <pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/primality-test/miller-rabin/</guid>
      <description>理论 TODO。
算法描述 TODO。
备注 需要 Montgomery 算法，u64 取模的开销过大。
参考 素数判定 - mathmu 代码 #ifndef ALGO_MATH_MILLER_RABIN #define ALGO_MATH_MILLER_RABIN #include &amp;quot;../../base.hpp&amp;quot; #include &amp;quot;../qpow/u64.hpp&amp;quot; #include &amp;lt;bit&amp;gt; #include &amp;lt;array&amp;gt; bool miller_rabbin_base(u64 n, u64 a) { u32 s = std::countr_zero(n - 1); u64 d = n &amp;gt;&amp;gt; s; u64 ad = qpow64(a, d, n); if (ad == 1 || ad == n - 1 || ad == 0) return true; for (u32 i = 1; i &amp;lt;= s - 1; ++i) { ad = u128(ad) * ad % n; if (ad == n - 1) return true; if (ad == 1) break; } return false; } bool miller_rabbin_test(u64 n) { if (n &amp;lt;= 6) return n == 2 || n == 3 || n == 5; if (n % 6 !</description>
    </item>
    
    <item>
      <title>Lucas 素性测试</title>
      <link>https://algo-cpp.rogery.dev/post/math/primality-test/lucas/</link>
      <pubDate>Sat, 21 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/primality-test/lucas/</guid>
      <description>理论 设 $D$ 为无平方整数，记 $O$ 为二次域 $\mathbb{Q}(\sqrt{D})$ 上的 代数整数环，有类比的定理：
【二次域中的 Fermat 小定理】设 $a \in O$ ， $p$ 为奇素数，且 $p \nmid d$ ，则
$$ a^p = \begin{cases} a, &amp;\text{若 } \left(\frac{D}{p}\right) = 1 \\ \overline{a}, &amp;\text{若 } \left(\frac{D}{p}\right) = -1\end{cases} \pmod p $$ 由于乘幂并不容易计算，引入一类特殊的二阶递推序列：设 $P, Q \in \mathbb{Z}$ ，特征方程 $x^2 - Px+ Q = 0$ 的两根分别为 $a, b$ ，定义 $P, Q$ 对应的 Lucas 序列为
$$ U_n = \frac{a^n - b^n}{a - b},\quad V_n = a^n + b^n $$ 我没理解乘幂计算的在哪里有困难，不能快速幂吗？猜测是那个除 $2$ 比较头疼。</description>
    </item>
    
    <item>
      <title>NTT</title>
      <link>https://algo-cpp.rogery.dev/post/math/poly/ntt/</link>
      <pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/poly/ntt/</guid>
      <description>多项式 NTT #ifndef ALGO_MATH_POLY_NTT #define ALGO_MATH_POLY_NTT #include &amp;quot;../../base.hpp&amp;quot; #include &amp;quot;../../other/modint/modint-concept.hpp&amp;quot; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;bit&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;span&amp;gt; #include &amp;lt;vector&amp;gt; namespace detail { u32 ntt_size = 0; } // namespace detail template &amp;lt;static_modint_concept ModT&amp;gt; auto &amp;amp;prepare_root(u32 m) { using ValueT = typename ModT::ValueT; static constexpr ValueT P = ModT::mod(); static constexpr ValueT g = 3; static constexpr ValueT max_bit = ValueT(1) &amp;lt;&amp;lt; std::countr_zero(ModT::mod() - 1); static std::vector&amp;lt;ModT&amp;gt; rt{1, 1}; assert(m &amp;lt;= max_bit); while (rt.</description>
    </item>
    
    <item>
      <title>Poly</title>
      <link>https://algo-cpp.rogery.dev/post/math/poly/poly/</link>
      <pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/math/poly/poly/</guid>
      <description>多项式 NTT #ifndef ALGO_MATH_POLY_BASE #define ALGO_MATH_POLY_BASE #include &amp;quot;../../other/modint/modint-concept.hpp&amp;quot; #include &amp;quot;ntt.hpp&amp;quot; #include &amp;quot;vec-dots.hpp&amp;quot; #include &amp;quot;inv-10E-nt-block.hpp&amp;quot; #include &amp;quot;div-10E-nt-block.hpp&amp;quot; #include &amp;quot;ln.hpp&amp;quot; #include &amp;quot;exp-14E-nt-block.hpp&amp;quot; #include &amp;quot;sqrt-8E-nt-block.hpp&amp;quot; #include &amp;quot;pow.hpp&amp;quot; #include &amp;quot;safe-sqrt.hpp&amp;quot; #include &amp;quot;safe-pow.hpp&amp;quot; #include &amp;quot;deriv.hpp&amp;quot; #include &amp;quot;integr.hpp&amp;quot; #include &amp;lt;optional&amp;gt; #include &amp;lt;vector&amp;gt; template &amp;lt;static_modint_concept ModT&amp;gt; class Poly : public std::vector&amp;lt;ModT&amp;gt; { using Vec = typename std::vector&amp;lt;ModT&amp;gt;; public: using Vec::empty; using Vec::resize; using Vec::size; using Vec::operator[]; using Vec::begin; using Vec::cbegin; using Vec::cend; using Vec::end; static constexpr auto m_inv = poly_inv_10E&amp;lt;ModT&amp;gt;; static constexpr auto m_deriv = poly_deriv&amp;lt;ModT&amp;gt;; static constexpr auto m_integr = poly_integr&amp;lt;ModT&amp;gt;; static constexpr auto m_div = poly_div_10E_block&amp;lt;ModT&amp;gt;; static constexpr auto m_ln = poly_ln&amp;lt;ModT, m_div&amp;gt;; static constexpr auto m_exp = poly_exp_14E_block&amp;lt;ModT&amp;gt;; static constexpr auto m_sqrt = poly_sqrt_8E_block&amp;lt;ModT&amp;gt;; static constexpr auto m_safe_sqrt = poly_safe_sqrt&amp;lt;ModT, m_sqrt&amp;gt;; static constexpr auto m_pow = poly_pow&amp;lt;ModT, m_ln, m_exp&amp;gt;; static constexpr auto m_safe_pow = poly_safe_pow&amp;lt;ModT, m_pow&amp;gt;; Poly() = default; Poly(u32 len) : Vec(len) {} Poly(const std::vector&amp;lt;u32&amp;gt; &amp;amp;v) : Vec(v) {} Poly(const std::vector&amp;lt;ModT&amp;gt; &amp;amp;v) : Vec(v) {} Poly(const ModT &amp;amp;v) : Vec({v}) {} Poly &amp;amp;operator+=(const Poly &amp;amp;rhs) { if (size() &amp;lt; rhs.</description>
    </item>
    
    <item>
      <title>算法库</title>
      <link>https://algo-cpp.rogery.dev/post/base/</link>
      <pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://algo-cpp.rogery.dev/post/base/</guid>
      <description>实现的算法列表。
数学相关 基础数论 Miller Rabin 素性测试，math/primality-test/miller-rabin.hpp。 Lucas 素性测试，math/primality-test/lucas.hpp。 Baillie PSW 素性测试，math/primality-test/baillie-psw.hpp。 Poly Poly 骨架，math/poly/poly-base.hpp。 NTT，math/poly/ntt.hpp。 牛顿迭代 多项式乘法逆 10E，math/poly/inv-10E-nt.hpp。 多项式乘法逆 12E，math/poly/inv-12E-nt.hpp。 多项式除法 13E，math/poly/div-13E-nt.hpp。 多项式 EXP 17E，math/poly/exp-17E-nt.hpp。 多项式开根 11E，math/poly/sqrt-11E-nt.hpp。 分块牛顿迭代 多项式乘法逆 10E 分块，math/poly/inv-10E-block.hpp。 多项式除法 10E 分块，math/poly/div-10E-nt-block.hpp。 多项式开根 8E 分块，math/poly/sqrt-8E-nt-block.hpp。 多项式 EXP 14E 分块，math/poly/exp-17E-nt-block.hpp。 </description>
    </item>
    
  </channel>
</rss>
